//! Example of glyph_brush usage with raw OpenGL.
//!
//! Uses instanced rendering with 1 vertex per glyph referencing a 1 byte per pixel texture.
//!
//! Controls
//! * Scroll to size text.
//! * Type to modify text.
//! * Resize window.
//! 
//! Rendering to a texture https://learnopengl.com/Advanced-OpenGL/Framebuffers
//! bloom https://learnopengl.com/Advanced-Lighting/Bloom

use std::{
    env,
    ffi::CString,
    io::{self, Write},
    mem, ptr, 
};
use gl::types::*;
use glutin::{Api, GlContext, GlProfile, GlRequest};
use glyph_brush::{rusttype::*, *};
mod helpers_for_glyph;
use helpers_for_glyph::*;
use rand::*;
mod gl_error_handler;
use gl_error_handler::*;
mod shader_compiler;
use shader_compiler::*;
mod gl_buffers;
use gl_buffers::*;

pub type Res<T> = Result<T, Box<std::error::Error>>;

fn main() -> Res<()> {

  // vvvv init context vvvv
  env_logger::init();

  if cfg!(target_os = "linux") {
      // winit wayland is currently still wip
      if env::var("WINIT_UNIX_BACKEND").is_err() {
          env::set_var("WINIT_UNIX_BACKEND", "x11");
      }
      // disables vsync sometimes on x11
      if env::var("vblank_mode").is_err() {
          env::set_var("vblank_mode", "0");
      }
  }

  let mut events = glutin::EventsLoop::new();
  let title = "glyph_brush opengl example - scroll to size, type to modify";

  let window = glutin::GlWindow::new(
      glutin::WindowBuilder::new()
          .with_dimensions((1600, 900).into())
          .with_title(title),
      glutin::ContextBuilder::new()
          .with_gl_profile(GlProfile::Core)
          .with_gl(GlRequest::Specific(Api::OpenGl, (4, 5))) // was 3.2
          .with_srgb(true),
      &events,
  )?;
  unsafe { window.make_current()? };

  // Load the OpenGL function pointers
  gl::load_with(|symbol| window.get_proc_address(symbol) as _);
  // ^^^^ init context ^^^^

  // vvvv setup program 1: Frame program vvvv
  
  let mut using_frame_buffer = false;
  let frame_vs = compile_shader(include_str!("shader/frame.vert.glsl"), gl::VERTEX_SHADER)?;
  let frame_fs = compile_shader(include_str!("shader/frame.frag.glsl"), gl::FRAGMENT_SHADER)?;
  let frame_program = link_program(frame_vs, frame_fs)?;
  let f_width: GLsizei = 1600; // 1920;
  let f_height: GLsizei = 900; // 1080;
  // let (f_width, f_height) = glyph_brush.texture_dimensions();
  let mut fbo: GLuint = 0;
  let mut rbo: GLuint = 0;
  let mut frame_vbo: GLuint = 0;
  let mut frame_vao: GLuint = 0;
  let mut frame_texture: GLuint = 0;
  let mut brightness_texture: GLuint = 0;
  unsafe {
    fbo = make_framebuffer();
    frame_texture = make_frame_texture(fbo, f_width as _, f_height as _);
    attach_texture_to_framebuffer(fbo, frame_texture, gl::COLOR_ATTACHMENT0);

    /*
    brightness_texture = make_frame_texture(fbo, f_width as _, f_height as _);
    attach_texture_to_framebuffer(fbo, brightness_texture, gl::COLOR_ATTACHMENT1); // for bloom
    let ats = [gl::COLOR_ATTACHMENT0, gl::COLOR_ATTACHMENT1];
    gl::DrawBuffers(1, ats.as_ptr() as _);
    // GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffers if framebuffer is not zero or the name of an existing framebuffer object.
    // GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
    // GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does not exist in the current GL context.
    // GL_INVALID_OPERATION is generated if any value in bufs is GL_BACK, and n is not one.
    println!("Now checking if DrawBuffers is OK...");
    gl_assert_ok!();
    */

    rbo = make_render_buffer(fbo, f_width as _, f_height as _);
    complete_framebuffer(fbo, rbo);
    let tup = make_frame_quad(frame_program);
    frame_vbo = tup.0;
    frame_vao = tup.1;
    gl_assert_ok!();
    println!("Frame program setup: everything is OK");
    using_frame_buffer = true;
  }
  // ^^^^ setup program 1: Font shaders ^^^^

  // vvvv setup program 2: Font shaders vvvv
  let font_bytes: &[u8] = include_bytes!("../fonts/retro computer_demo.ttf");
  let mut glyph_brush = GlyphBrushBuilder::using_font_bytes(font_bytes).build();

  let vs = compile_shader(include_str!("shader/text.vert.glsl"), gl::VERTEX_SHADER)?;
  let fs = compile_shader(include_str!("shader/text.frag.glsl"), gl::FRAGMENT_SHADER)?;
  let program = link_program(vs, fs)?;

  let mut vao = 0;
  let mut vbo = 0;
  let mut glyph_texture = 0;

  unsafe {
    // Create Vertex Array Object
    gl::GenVertexArrays(1, &mut vao);
    gl::BindVertexArray(vao);

    // Create a Vertex Buffer Object
    gl::GenBuffers(1, &mut vbo);
    gl::BindBuffer(gl::ARRAY_BUFFER, vbo);

    {
      // Create a texture for the glyphs
      // The texture holds 1 byte per pixel as alpha data
      gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);
      gl::GenTextures(1, &mut glyph_texture);
      gl::BindTexture(gl::TEXTURE_2D, glyph_texture);
      gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as _);
      gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as _);
      gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as _);
      gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as _);
      let (width, height) = glyph_brush.texture_dimensions();
      println!("glyph_brush w, h: {}, {}", width, height);
      gl::TexImage2D(
          gl::TEXTURE_2D,
          0,
          gl::RED as _,
          width as _,
          height as _,
          0,
          gl::RED,
          gl::UNSIGNED_BYTE,
          ptr::null(),
      );
      gl_assert_ok!();
    }

    // Use shader program
    gl::UseProgram(program);
    gl::BindFragDataLocation(program, 0, CString::new("out_color")?.as_ptr());

    // Specify the layout of the vertex data
    setup_attribs(
      program, 
      mem::size_of::<VertexForGlyph>() as _, 
      true,
      &[
        ("left_top", 3),
        ("right_bottom", 2),
        ("tex_left_top", 2),
        ("tex_right_bottom", 2),
        ("color", 4),
      ]
    )?;

    // Enabled alpha blending
    gl::Enable(gl::BLEND);
    gl::BlendFunc(gl::SRC_ALPHA, gl::ONE_MINUS_SRC_ALPHA);
    // Use srgb for consistency with other examples
    gl::Enable(gl::FRAMEBUFFER_SRGB);
    gl::ClearColor(0.02, 0.02, 0.02, 1.0);
    // vao is used after this somewhere...
  }
  // */
  // ^^^^ setup program 2: Font shaders ^^^^

  let mut text: String = include_str!("text/lipsum.txt").into();
  let mut font_size: f32 = 18.0;
  let mut loop_helper = spin_sleep::LoopHelper::builder().build_with_target_rate(250.0);
  let mut running = true;
  let mut vertex_count = 0;
  let mut vertex_max = vertex_count;
  let mut dimensions = window
      .get_inner_size()
      .ok_or("get_inner_size = None")?
      .to_physical(window.get_hidpi_factor());
  let mut rng = rand::thread_rng();

  // println!("Time to enter events loop"); // DEBUG
  while running {
    // vvvv events loop vvvv
    loop_helper.loop_start();
    events.poll_events(|event| {
      use glutin::*;
      if let Event::WindowEvent { event, .. } = event {
        match event {
          WindowEvent::CloseRequested => running = false,
          WindowEvent::Resized(size) => {
            let dpi = window.get_hidpi_factor();
            window.resize(size.to_physical(dpi));
            if let Some(ls) = window.get_inner_size() {
              dimensions = ls.to_physical(dpi);
              unsafe {
                gl::Viewport(0, 0, dimensions.width as _, dimensions.height as _);
              }
            }
          }
          WindowEvent::KeyboardInput {
            input:
              KeyboardInput {
                state: ElementState::Pressed,
                virtual_keycode: Some(keypress),
                ..
              },
            ..
          } => match keypress {
            VirtualKeyCode::Escape => running = false,
            VirtualKeyCode::Back => {
              text.pop();
            }
            _ => (),
          },
          WindowEvent::ReceivedCharacter(c) => {
            if c != '\u{7f}' && c != '\u{8}' {
              text.push(c);
            }
          }
          WindowEvent::MouseWheel {
            delta: MouseScrollDelta::LineDelta(_, y),
            ..
          } => {
            // increase/decrease font size
            let old_size = font_size;
            let mut size = font_size;
            if y > 0.0 {
              size += (size / 4.0).max(2.0)
            } else {
                size *= 4.0 / 5.0
            };
            font_size = size.max(1.0).min(2000.0);
            if (font_size - old_size).abs() > 1e-2 {
              eprint!("\r                            \r");
              eprint!("font-size -> {:.1}", font_size);
              let _ = io::stderr().flush();
            }
          }
          _ => {}
        }
      }
    });
    // ^^^^ events loop ^^^^
    
    // vvvv glyph brush queue vvvv
    let width = dimensions.width as f32; // use this if you render to viewport
    let height = dimensions.height as _;
    let scale = Scale::uniform((font_size * window.get_hidpi_factor() as f32).round());
    
    // println!("Time queu glyph brush section 1"); // DEBUG
    glyph_brush.queue(Section {
      text: &text,
      scale,
      screen_position: (0.0, 0.0),
      bounds: (width / 3.15, height),
      color: [0.9, 0.3, 0.3, 1.0],
      ..Section::default()
    });

    // println!("Time queu glyph brush section 2"); // DEBUG
    glyph_brush.queue(Section {
      text: &text,
      scale,
      screen_position: (width / 2.0, height / 2.0),
      bounds: (width / 3.15, height),
      color: [0.3, 0.9, 0.3, 1.0],
      layout: Layout::default()
        .h_align(HorizontalAlign::Center)
        .v_align(VerticalAlign::Center),
      ..Section::default()
    });

    // println!("Time queu glyph brush section 3"); // DEBUG
    glyph_brush.queue(Section {
      text: &text,
      scale,
      screen_position: (width, height),
      bounds: (width / 3.15, height),
      color: [0.3, 0.3, 0.9, 1.0],
      layout: Layout::default()
        .h_align(HorizontalAlign::Right)
        .v_align(VerticalAlign::Bottom),
      ..Section::default()
    });
    // ^^^^ glyph brush queue ^^^^

    // vvvv handle glyph brush action vvvv
    // println!("Time to loop over brush actions"); // DEBUG
    let mut brush_action;
    loop {
      unsafe { gl::BindTexture(gl::TEXTURE_2D, glyph_texture); }
      brush_action = glyph_brush.process_queued(
        (width as _, height as _),
        |rect, tex_data| unsafe {
          // Update part of gpu texture with new glyph alpha values
          gl::TexSubImage2D(
            gl::TEXTURE_2D,
            0,
            rect.min.x as _,
            rect.min.y as _,
            rect.width() as _,
            rect.height() as _,
            gl::RED,
            gl::UNSIGNED_BYTE,
            tex_data.as_ptr() as _,
          );
          gl_assert_ok!();
        },
        to_vertex,
      );

      // println!("Time to match brush actions for resize"); // DEBUG
      match brush_action {
        Ok(_) => break,
        Err(BrushError::TextureTooSmall { suggested, .. }) => unsafe {
          let (new_width, new_height) = suggested;
          eprint!("\r                            \r");
          eprintln!("Resizing glyph texture -> {}x{}", new_width, new_height);
          // Recreate texture as a larger size to fit more
          gl::TexImage2D(
            gl::TEXTURE_2D,
            0,
            gl::RED as _,
            new_width as _,
            new_height as _,
            0,
            gl::RED,
            gl::UNSIGNED_BYTE,
            ptr::null(),
          );
          gl_assert_ok!();
          glyph_brush.resize_texture(new_width, new_height);
        },
      }
    }
    // println!("Time to match brush actions for draw"); // DEBUG
    match brush_action? {
      BrushAction::Draw(vertices) => {
        // Draw new vertices
        vertex_count = vertices.len();
        unsafe {
          if vertex_max < vertex_count {
            gl::BufferData(
              gl::ARRAY_BUFFER,
              (vertex_count * mem::size_of::<VertexForGlyph>()) as GLsizeiptr,
              vertices.as_ptr() as _,
              gl::DYNAMIC_DRAW,
            );
          } else {
            gl::BufferSubData(
              gl::ARRAY_BUFFER,
              0,
              (vertex_count * mem::size_of::<VertexForGlyph>()) as GLsizeiptr,
              vertices.as_ptr() as _,
            );
          }
        }
        vertex_max = vertex_max.max(vertex_count);
      }
      BrushAction::ReDraw => {}
    }
    // ^^^^ handle glyph brush action ^^^^

    // vvvv DRAW vvvv
    unsafe {
      // pass 1
      gl::BindFramebuffer(gl::FRAMEBUFFER, fbo);
      gl::ClearColor(0.02, 0.02, 0.02, 1.0);
      gl::Clear(gl::COLOR_BUFFER_BIT);
      gl::UseProgram(program);
      gl::BindTexture(gl::TEXTURE_2D, glyph_texture);
      gl::BindVertexArray(vao);
      gl::DrawArraysInstanced(gl::TRIANGLE_STRIP, 0, 4, vertex_count as _);

      // pass 2
      gl::BindFramebuffer(gl::FRAMEBUFFER, 0); // back to default framebuffer
      gl::ClearColor(0.1, 0.0, 0.0, 1.0);
      gl::Clear(gl::COLOR_BUFFER_BIT);
      gl::BindTexture(gl::TEXTURE_2D, frame_texture);
      gl::UseProgram(frame_program);
      let uloc = gl::GetUniformLocation(frame_program, CString::new("baseRand")?.as_ptr());
      let rand_val: f32 = rng.gen();
      gl::Uniform1f(uloc, rand_val);
      gl::BindVertexArray(frame_vao);
      gl::DrawArrays(gl::TRIANGLES, 0, 6);
    }
    window.swap_buffers()?;
    // ^^^^ DRAW ^^^^

    // update loop helper
    if let Some(rate) = loop_helper.report_rate() {
      window.set_title(&format!("{} {:.0} FPS", title, rate));
    }
    loop_helper.loop_sleep();
    // update loop helper
  }

  // vvvv cleanup vvvv
  unsafe {
      gl::DeleteProgram(program);
      gl::DeleteShader(fs);
      gl::DeleteShader(vs);
      gl::DeleteBuffers(1, &vbo);
      gl::DeleteVertexArrays(1, &vao);
      gl::DeleteTextures(1, &glyph_texture);
      
      if using_frame_buffer {
        gl::DeleteProgram(frame_program);
        gl::DeleteShader(frame_vs);
        gl::DeleteShader(frame_fs);
        gl::DeleteBuffers(1, &frame_vbo);
        gl::DeleteVertexArrays(1, &frame_vao);
        gl::DeleteTextures(1, &frame_texture);
        gl::DeleteFramebuffers(1, &fbo);
        gl::DeleteRenderbuffers(1, &rbo);
      }
  }
  // ^^^^ cleanup ^^^^
  Ok(())
}