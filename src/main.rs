//! Example of glyph_brush usage with raw OpenGL.
//!
//! Uses instanced rendering with 1 vertex per glyph referencing a 1 byte per pixel texture.
//!
//! Controls
//! * Scroll to size text.
//! * Type to modify text.
//! * Resize window.
//! 
//! Rendering to a texture https://learnopengl.com/Advanced-OpenGL/Framebuffers
//! bloom https://learnopengl.com/Advanced-Lighting/Bloom

use glutin::{GlWindow};
use spin_sleep::LoopHelper;

mod shader_compiler;
mod gl_buffers;
#[macro_use]
mod gl_error_handler;
mod helpers_for_glyph;

mod scene;
use scene::*;
mod noise_scene;
use noise_scene::*;
mod text_scene;
use text_scene::*;
mod event_handler;
use event_handler::*;
mod context;
use context::*;

pub type Res<T> = Result<T, Box<std::error::Error>>;

  // todo: make a bloom scene
  /*
  let mut brightness_texture: GLuint = 0;
  brightness_texture = make_frame_texture(fbo, f_width as _, f_height as _);
  attach_texture_to_framebuffer(fbo, brightness_texture, gl::COLOR_ATTACHMENT1); // for bloom
  let ats = [gl::COLOR_ATTACHMENT0, gl::COLOR_ATTACHMENT1];
  gl::DrawBuffers(1, ats.as_ptr() as _);
  // GL_INVALID_OPERATION error is generated by glNamedFramebufferDrawBuffers if framebuffer is not zero or the name of an existing framebuffer object.
  // GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
  // GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does not exist in the current GL context.
  // GL_INVALID_OPERATION is generated if any value in bufs is GL_BACK, and n is not one.
  println!("Now checking if DrawBuffers is OK...");
  gl_assert_ok!();
  */

fn main() -> Res<()> {
  let title = "glyph_brush opengl example - scroll to size, type to modify";
  let (window, mut events) = init_context(title)?;
  // INIT
  let mut noise_scene = NoiseScene::new(include_str!("shader/noise.vert.glsl"), include_str!("shader/noise.frag.glsl"));
  noise_scene.init();
  let mut text_scene = TextScene::new(include_str!("shader/text.vert.glsl"), include_str!("shader/text.frag.glsl"), &window);
  text_scene.init();
  let mut loop_helper = spin_sleep::LoopHelper::builder().build_with_target_rate(250.0);
  let mut running = true;
  // RUN
  while running {
    loop_helper.loop_start();
    handle_events(&mut events, &mut running, &window, &mut text_scene)?;
    text_scene.update(&window);
    draw(&noise_scene, &text_scene, &window)?;
    update_loop_helper(&mut loop_helper, &window, title);
  }
  // CLEANUP
  text_scene.cleanup();
  noise_scene.cleanup();
  Ok(())
}

fn draw(noise_scene: &NoiseScene, text_scene: &TextScene, window: &GlWindow) -> Res<()> {
  unsafe {
    gl::BindFramebuffer(gl::FRAMEBUFFER, noise_scene.fbo); // todo: set render target in scene
    text_scene.draw();
    noise_scene.draw();
  }
  window.swap_buffers()?;
  Ok(())
}

fn update_loop_helper(loop_helper: &mut LoopHelper, window: &GlWindow, title: &str) {
  if let Some(rate) = loop_helper.report_rate() {
    window.set_title(&format!("{} {:.0} FPS", title, rate));
  }
  loop_helper.loop_sleep();
}